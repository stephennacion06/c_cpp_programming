# Algorithms

Common algorithms and problem-solving techniques in C/C++.

## üìö Topics Covered

### Beginner Level
- [ ] **Linear Search**: Sequential search
- [ ] **Binary Search**: Efficient searching
- [ ] **Bubble Sort**: Simple sorting algorithm
- [ ] **Selection Sort**: Selection-based sorting
- [ ] **Insertion Sort**: Incremental sorting
- [ ] **String Algorithms**: Reverse, palindrome, anagram
- [ ] **Basic Math**: GCD, LCM, prime numbers
- [ ] **Array Operations**: Rotation, reversal, sum

### Intermediate Level
- [ ] **Merge Sort**: Divide and conquer
- [ ] **Quick Sort**: Partition-based sorting
- [ ] **Heap Sort**: Heap-based sorting
- [ ] **Counting Sort**: Integer sorting
- [ ] **Radix Sort**: Non-comparison sorting
- [ ] **Two Pointers**: Array manipulation
- [ ] **Sliding Window**: Subarray problems
- [ ] **Recursion**: Factorial, Fibonacci, towers of Hanoi
- [ ] **Backtracking**: N-Queens, Sudoku solver
- [ ] **Greedy Algorithms**: Activity selection, Huffman coding

### Advanced Level
- [ ] **Dynamic Programming**: Memoization and tabulation
  - Longest Common Subsequence
  - Knapsack problem
  - Edit distance
  - Matrix chain multiplication
- [ ] **Graph Algorithms**:
  - Breadth-First Search (BFS)
  - Depth-First Search (DFS)
  - Dijkstra's shortest path
  - Bellman-Ford algorithm
  - Floyd-Warshall algorithm
  - Minimum spanning tree (Kruskal's, Prim's)
- [ ] **String Matching**:
  - KMP algorithm
  - Rabin-Karp algorithm
  - Boyer-Moore algorithm
- [ ] **Divide and Conquer**: Advanced applications
- [ ] **Bit Manipulation**: XOR tricks, bit masking

## üéØ Learning Objectives

For each algorithm, you'll learn:
- **Algorithm Design**: Understanding the approach
- **Time Complexity**: Best, average, worst case
- **Space Complexity**: Memory requirements
- **Applications**: Real-world use cases
- **Optimization**: Improving performance

## üìä Complexity Analysis

Each implementation includes:
- Big O notation explanation
- Time complexity analysis
- Space complexity analysis
- Comparison with alternative approaches

## üìñ Learning Path

1. **Beginner**: Master basic searching and sorting
2. **Intermediate**: Learn efficient algorithms and techniques
3. **Advanced**: Study complex algorithms and optimization

## üî® Building and Running

```bash
# Build all algorithm examples
cd build
cmake --build . --target algorithms

# Run specific algorithm
./bin/algorithms/binary_search
```

## üí° Problem-Solving Tips

- Understand the problem before coding
- Consider time and space constraints
- Start with brute force, then optimize
- Test with edge cases
- Practice regularly

## üìù Contributing

Help expand the algorithm collection! See [CONTRIBUTING.md](../CONTRIBUTING.md).
